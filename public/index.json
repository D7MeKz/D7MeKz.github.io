
[{"content":"","date":"22 May 2024","externalUrl":null,"permalink":"/tags/entgo/","section":"Tags","summary":"","title":"Entgo","type":"tags"},{"content":" ORM 선택 # Go의 경우에는 JAVA와 달리 대표적인 ORM 프레임워크가 없어, 개발자가 직접 선택해서 사용해야 한다.\n다양한 Go ORM 프레임워크 순위를 알고 싶다면 OSS Insight 를 참고하길 바란다.\n기본적으로 mysql driver 사용을 생각했다. 그러나 정교한 저수준의 쿼리를 다루는 것이 아니기 때문에 ORM를 적극적으로 활용하고 싶었다.\n조건 # 깔끔한 도메인 정의 여러 종류의 DB 지원 컴파일 레벨에서 디버깅 가능 Ent # Ent란 Facebook에서 개발한 Go ORM이다. 공식 설명에 의하면 그래프 구조의 데이터베이스 스키마를 가지고 있으며, 코드 생성을 기반으로 하는 정적 타이핑을 지원한다.1 이는 위에서 말한 조건에 어느 정도 충족이 된다.\n다만 ent는 관계형 데이터베이스에 적합하며 NoSQL 기반 데이터베이스에는 적합하지 않았다.2 ORM 선택 조건에는 부합하지 않았으나 대부분의 ORM이 RDB 위주로 지원한다는 것3을 감안했을때 ent은 RDB 사용 시 괜찮은 선택이라고 생각한다.\n초반에 Gorm 사용도 고려했다. 그러나 모델을 정의하는데 사용되는 struct tag 는 개인적으로 가독성이 좋지 않다는 인상이 들었다.\ntype Model struct { ID uint `gorm:\u0026#34;primaryKey\u0026#34;` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\u0026#34;index\u0026#34;` } 첫인상 # ORM 라이브러리의 schema를 본 순간 그래프 데이터베이스인 줄 알았다. 과거에 Neo4j4라는 그래프 데이터베이스를 사용해본 적이 있는데, 이 노드, 그래프를 별도로 정의해서 구현한 점이 상당히 유사했기 때문이다.\ntype Task struct { ent.Schema } // Fields of the Task. func (Task) Fields() []ent.Field { return []ent.Field{ field.Int(\u0026#34;id\u0026#34;), field.String(\u0026#34;title\u0026#34;), field.Int(\u0026#34;total_status\u0026#34;), field.Time(\u0026#34;created_at\u0026#34;).Default(time.Now()), field.Time(\u0026#34;modified_at\u0026#34;).Default(time.Now()), } } // Edges of the Task. func (Task) Edges() []ent.Edge { return []ent.Edge{ edge.To(\u0026#34;subtask\u0026#34;, SubTask.Type), } } 공식 홈페이지를 참고해보면 Ent ORM에 대해 이렇게 설명했다.\nEasily model database schema as a graph structure.\nschema 구조를 그래프 구조로 구현되어 있다는 것이다. 아마 ent가 그래프 탐색에 대한 자신감을 표현한 것도 구조적인 이유때문이지 않을까 싶다.\n적용하기 # Schema # ent의 참조 방식은 독특하다. 기존의 참조 방식과 반대이기 때문이다.5 ent 공식 문서에 의하면 edge.To를 사용하고 있으면 설정한 Edge를 소유한다고 정의한다.6\nA schema that defines an edge using the edge.To builder owns the relation, unlike using the edge.From builder that gives only a back-reference for the relation (with a different name).\n🤔 필자의 경우 위의 정의를 고려하고 구현하니 더 헷갈리기 시작했다. 그래서 관계 소유자인 schema만 정의하고, 그 외에는 서로의 연관관계를 설정해준다는 마음으로 구현했다.\nMember : Task Entity가 1:N 연관 관계를 가진다고 가정해보자.\nMember는 tasks라는 관계의 소유자이다. 그러므로 edge.To로 관계를 설정한다. 하지만 Task는 many에 해당되기 때문에 아무것도 설정하지 않는다.\n// Fields of the Member. func (Member) Fields() []ent.Field { return []ent.Field{ field.Int(\u0026#34;id\u0026#34;), field.String(\u0026#34;email\u0026#34;), field.String(\u0026#34;username\u0026#34;), field.String(\u0026#34;password\u0026#34;), field.Time(\u0026#34;created_at\u0026#34;).Default(time.Now()), } } // Edges of the Member. func (Member) Edges() []ent.Edge { return []ent.Edge{ edge.To(\u0026#34;tasks\u0026#34;, Task.Type), } } Task에서는 Member에서 소유한 관계(user)를 역참조해서 관계를 정의하게 된다. 이때 Member는 관계에서 One에 해당되니 Unique() 함수를 붙이게 된다.\n// Fields of the Task. func (Task) Fields() []ent.Field { return []ent.Field{ field.Int(\u0026#34;id\u0026#34;), field.String(\u0026#34;title\u0026#34;), field.Int(\u0026#34;total_status\u0026#34;), field.Time(\u0026#34;created_at\u0026#34;).Default(time.Now()), field.Time(\u0026#34;modified_at\u0026#34;).Default(time.Now()), } } // Edges of the Task. func (Task) Edges() []ent.Edge { return []ent.Edge{ edge.From(\u0026#34;member\u0026#34;, Member.Type).Ref(\u0026#34;tasks\u0026#34;).Unique(), } } 참조하는 이유는 어떤 schema와 참조하는지를 명시하기 위해서라고 보면 된다.\n\u0026hellip; because there can be multiple references from one schema to other.\n예제 - 데이터 생성 코드 # 그럼 데이터를 생성할때 어떻게 해야할까? 참조하는 Schema(Task)에서 Member 정보를 추가해주면 된다.\n공식 문서에서는 직접 Query해서 데이터를 가져왔지만7 , 그 외에도 Schema 데이터( 예제에서는 ent.Member) 혹은 아이디만으로도 추가가 가능하니 공식 문서를 참고하길 바란다.\nfunc (s *Store) Create(ctx *gin.Context, b request.CreateTask) error { // create Task _, err := s.client.Task.Create().SetTitle(b.Title).SetTotalStatus(0) .SetMemberID(b.UserId).Save(ctx) if err != nil { return err } return nil } 실제로 데이터베이스를 보면 {참조하는 관계명} _ {참조하는 관계명}으로 이뤄져 있다.\n위의 예제에서는 1:N(One-to-Many)인 경우에면 설명했지만 (M:N)의 경우에는 {참조하는 관계명} _ {참조하는 관계명}의 이름을 가진 테이블이 생성된다.\nhttps://entgo.io/docs/getting-started/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n필자는 MongoDB에 적용시키고자 검색을 여러번 했지만 끝내 찾지 못했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.billo.io/devposts/go_orm_recommandation/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://neo4j.com/docs/getting-started/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://umi0410.github.io/blog/golang/how-to-backend-in-go-db/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://entgo.io/docs/schema-edges#quick-summary\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://entgo.io/docs/schema-edges#o2o-two-types\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"22 May 2024","externalUrl":null,"permalink":"/posts/entgo-1/","section":"Posts","summary":"ORM 선택 # Go의 경우에는 JAVA와 달리 대표적인 ORM 프레임워크가 없어, 개발자가 직접 선택해서 사용해야 한다.","title":"Entgo - Ent ORM","type":"posts"},{"content":"","date":"22 May 2024","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"22 May 2024","externalUrl":null,"permalink":"/","section":"NooOTe","summary":"","title":"NooOTe","type":"page"},{"content":"","date":"22 May 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"22 May 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"11 May 2024","externalUrl":null,"permalink":"/tags/gin/","section":"Tags","summary":"","title":"Gin","type":"tags"},{"content":"","date":"11 May 2024","externalUrl":null,"permalink":"/project/","section":"Projects","summary":"","title":"Projects","type":"project"},{"content":"","date":"11 May 2024","externalUrl":null,"permalink":"/tags/testing/","section":"Tags","summary":"","title":"Testing","type":"tags"},{"content":" GitHub : Thumbnail: Designed by Freepik ","date":"11 May 2024","externalUrl":null,"permalink":"/project/todopoint/","section":"Projects","summary":" GitHub : Thumbnail: Designed by Freepik ","title":"Todopoint","type":"project"},{"content":"Go를 활용하여 직접 2개의 서비스를 만들고 나니, 구현할때 지나쳤던 에러들이 큰 눈덩이로 변해서 덮쳐왔다. 문제가 생긴 지점은 명확했지만, 그것보다는 문제 발생의 근본적인 원인을 찾고자 했었다. 내가 생각한 가장 큰 원인은 테스트 코드의 부재였다. 테스트의 장점은 누구나 알고 있을 것이다. 코드의 안전성을 확보할 수 있으며 문제 발생 시 빠르게 수정할 수 있다는 것이다. 현재 코드에는 숨겨진 구멍들이 존재하는데, 이를 해결하기 위해서는 단위 테스트, 통합 테스트가 필요했다. 기존에 있던 코드를 활용하여 테스트 코드로 작성하려고 시도했으나, 지금까지 적은 Go 코드는 테스트를 용이하도록 작성되지 않았다. 특히 인터페이스를 적절하게 사용하지 않아서 Mock를 사용하는데 어려움이 생기기도 했다.\n그래서 과감하게 처음부터 다시 쓰기로 했다. 이번까지 포함해서 코드를 총 2번 수정했는데, 그 과정을 적고자 한다.\n초기 - Go 한달차의 적응기 # 에러 타입과 상태 타입 # 1차에서는 ErrorType으로 특정 에러 타입을 정의하는데 사용할 타입을 지정해줬다.\ntype ErrorType int type Error struct { // Code is a custom error code ErrorType ErrorType // Err is a error string Err error // Description is a human-friendly message. Description string } type ErrorRes struct { // Code is http status code Code int `json:\u0026#34;code\u0026#34;` } 모든 서비스들이 사용할 경우, 각 서비스가 사용할 에러 코드를 일리리 지정했다. map를 활용하여 에러 타입에 해당되는 상태 코드를 매핑했다.\nconst ( // Common SUCCESS ErrorType = 0 INVALID_JSON_FORMAT ErrorType = 1001 INVALID_URI_FORMAT ErrorType = 1002 // Member INVALID_MEMBER ErrorType = 2001 ERROR_MEMBER_DB ErrorType = 2101 // Task ERROR_TASK_DB ErrorType = 3101 ) var codeMap = map[ErrorType]int{ // Common INVALID_JSON_FORMAT: http.StatusBadRequest, INVALID_URI_FORMAT: http.StatusBadRequest, // Member INVALID_MEMBER: http.StatusUnauthorized, ERROR_MEMBER_DB: http.StatusInternalServerError, // Task ERROR_TASK_DB: http.StatusInternalServerError, } 에러 반환 # 직접 커스텀한 에러값을 입력값으로 해서 context를 활용해 Json 형태로 반환해줬다.\n// getCode is get Status code from codeMap. func getCode(flag ErrorType) *ErrorRes { return \u0026amp;ErrorRes{Code: codeMap[flag]} } func ErrorFunc(ctx *gin.Context, err *Error) { res := getCode(err.ErrorType) log.Println(err) ctx.AbortWithStatusJSON(res.Code, res) return } \u0026ldquo;저렇게 하면 오류가 제대로 반환되지 않을텐데?\u0026ldquo;라고 생각하는 사람이 있을 것이다. 저때 당시 gin이 에러를 응답하는 매커니즘을 잘 몰라 단순하게 AbortWithStatusJson으로 응답하도록 했다. 비록 결과는 에러 json + 성공 json 둘다 나왔지만 말이다.\n1차 - Middleware가 있었다고요? # gin의 오류 처리 매커니즘을 제대로 이해하지 못해 단순하게 응답을 처리했다. 이제는 Middleware를 제작함으로써 에러 응답 반환이 수월하도록 구현했다.\n에러 상태 타입 # ErrorType -\u0026gt; WebCode로 이름을 변경했으며, 에러뿐만 아니라 상태 전체를 표시했다. 여기서 눈치 빠르신 분은 알겠지만 에러 타입에는 상태값을 직접 포함하도록 구현했다. 왜냐하면 상태 코드를 추가할 일이 많은데 작업을 두번해야 하기 때문이다.\nTaskCreationSuccess WebCode = 220101 SubtaskCreationSuccess WebCode = 220151 예로 220101 이라면 2(Task Service)/201(Status code)/01(Unique number)로 구성하도록 했다.\n에러 타입과 반환 # 이전에는 에러 타입을 Error라고 정했지만 gin 내부의 에러를 쓰면서 헷갈리기 시작했다. 그래서 NetError로 이름을 변경했으며, Description field는 잘 사용하지 않는 것 같아 삭제했다.\ntype NetError struct { Code codes.WebCode Err error } func NewNetError(code codes.WebCode, err error) *NetError { logrus.Errorf(\u0026#34;Code : %d, Error : %v\u0026#34;, code, err) if err != nil { return \u0026amp;NetError{Code: code, Err: err} } return \u0026amp;NetError{Code: code, Err: nil} } 에러는 동일하게 code만 반환하도록 구현했다.\n// Response type ErrorResponse struct { Code codes.WebCode `json:\u0026#34;codes\u0026#34;` } func NewErrorResponse(code codes.WebCode) *ErrorResponse { return \u0026amp;ErrorResponse{Code: code} } 성공 # 응답값을 생각해보면 크게 두 가지가 존재한다.\n데이터가 없는 경우 데이터가 있는 경우 이 두가지를 나눠서 별도의 함수를 만들었다.\nfunc SuccessWith(ctx *gin.Context, code codes.WebCode, data any) { status := codes.GetStatus(code) res := NewSuccessResponseWith(code, data) ctx.Header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) ctx.AbortWithStatusJSON(status, res) } func Success(ctx *gin.Context, code codes.WebCode) { status := codes.GetStatus(code) ctx.Header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) res := NewSuccessResponse(code) ctx.JSON(status, res) } 에러 반환 로직은 gin Middleware를 사용했다. 자세한 사항은 아래의 글을 참고하길 바란다.\n2차 - 프론트엔드를 하고나니\u0026hellip; # 왜 백엔드와 프론트엔드가 짝꿍이 맞아야 하는지 알 것 같았다. 플러터의 경우에는 응답값과 똑같은 필드를 가진 모델로 반환해야 한다. 만약에 정확하게 받지 못하면, 아무런 값도 받을 수 없다.(심지어 상태값도 말이다.) 플러터로써는 해결 방안을 찾지 못해서 서버측에서 성공이든 오류든 모두 동일한 형태로 반환하도록 구현해야 했었다.\nResponse Format # 위에서 1차, 2차를 보면 구체적인 메세지가 없었다. 메세지를 넣지 않은 이유는 클라이언트에게 저런것까지 보여줄 필요가 없다고 생각해서였다. 그러나 앱개발하면서 정보가 없어서 정말 힘들었다. 😥\nError Response의 Best Practice를 찾아보니 대부분 자체적인 code와 이를 설명하는 메세지가 포함되어 있었다.1 이번에 수정한 응답에서는 메세지를 추가하기로 했다.\n에러 상태 타입 # 일단 지금까지 사용했던 에러 코드보다 길이를 더 축소시켰다. 그래서 자주 사용하는 상태 코드를 백의 자리로 두고, 1씩 카운트를 추가하면서 에러 코드를 정의했다. 또한 에러코드에 매핑되는 에러 메세지를 추가함으로써, 동일한 에러 메세지를 반환하도록 했다. 메세지는 정확하게 적지 않고, 문제를 전반적으로 보여줄 수 있도록 작성했다.\nconst ( // 1xx is Bad Request error code InvalidHeader ErrorCode = 101 InvalidBody ErrorCode = 102 InvalidQuery ErrorCode = 103 // 2xx is Unauthorized error code BadAuthenticationData ErrorCode = 201 TokenExpired ErrorCode = 202 ... ) var errorMessage = map[ErrorCode]string{ InvalidHeader: \u0026#34;The provided header values are invalid.\u0026#34;, InvalidBody: \u0026#34;The body of the request is invalid.\u0026#34;, InvalidQuery: \u0026#34;The query parameters are invalid.\u0026#34;, ... } 에러 타입 # netErrorOptions 라는 옵션을 추가시켰는데, 여기에는 서비스의 메타 정보가 포함되어 있다.\n// NetError have options and ErrorCode that contains status code. type NetError struct { // options is metadata about service options netErrorOptions // Type is a unique data that contains http status code. Code ErrorCode // Description is an error details. Description string // Err is an error message. Err error } 메타 정보로써 태그가 있는데, 서비스 이름을 문자열로 표시하는 것이다. 태그는 서버에서 디버깅을 조금더 수월하게 하기 위해서 도입했다. 오류코드가 모두 동일해서 어떤 서비스의 오류인지 명시하는 용도로 사용된다.\n// netErrorOptions is meta data about service type netErrorOptions struct { // tag is the service name tag string } 이 태그는 애플리케이션을 시작할때 한번만 설정하도록 함으로써, 모든 NetError가 해당 tag를 가지도록 구현했다.\nvar ( opts netErrorOptions ) // netErrorOptions is meta data about service type netErrorOptions struct { // tag is the service name tag string } // SetTag sets the service name func SetTag(tag string) { mu := sync.Mutex{} mu.Lock() defer mu.Unlock() opts.tag = tag } 에러 반환 # 에러는 크게 두 가지로 나눠져 있다.\nStatus: 응답의 타입 (\u0026ldquo;Success\u0026rdquo; or \u0026ldquo;Error\u0026rdquo;) Data : 에러 데이터 혹은 성공 시 반환할 데이터 // BaseResponse is common response that use in success and failed type BaseResponse struct { Status string `json:\u0026#34;status\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } 다만 생성자를 만들때 성공, 실패 여부를 따로 만들었다. 그 이유는 입력하는 값이 다 달랐기 때문이다.\n성공한 경우 반환하고자 하는 데이터를 Data 필드에 넣기만 하면 된다.\nfunc NewSuccessBaseResponse(data interface{}) *BaseResponse { return \u0026amp;BaseResponse{ Status: \u0026#34;Success\u0026#34;, Data: data, } } 그러나 오류인 경우는 다르다. 반환할 오류 타입은 형식화되어 있으므로, ErrorResponse 구조체를 따로 만들어서 Data 필드에 저장했다.\n// ErrorResponse is the error response format type ErrorResponse struct { Code ErrorCode `json:\u0026#34;code\u0026#34;` Message string `json:\u0026#34;message\u0026#34;` } func NewErrorBaseResponse(data NetError) *BaseResponse { res := ErrorResponse{Code: data.Code, Message: GetErrorMsg(data.Code)} return \u0026amp;BaseResponse{ Status: \u0026#34;Error\u0026#34;, Data: res, } } BaseResponse가 반환되면, 메소드로 응답값을 반환하도록 구현했다.\n// Failed response failed formatted response. // It converts NetError to ErrorResponse to extract necessary things. func (b BaseResponse) Failed(ctx *gin.Context) { res := b.GetErrorData() status := parseStatusCode(res.Code) ctx.AbortWithStatusJSON(status, b) return } // OKSuccess uses when status code is 200 func (b BaseResponse) OKSuccess(ctx *gin.Context) { ctx.Header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) ctx.AbortWithStatusJSON(200, b) } 테스트 # gin 테스트 사례2를 참고해서 성공했을 경우의 테스트 코드를 작성해보았다.\n테스트 코드는 테이블 중심 테스트(Table-Driven Test) 방식3을 채택했다. 단위 테스트가 비슷한 구조로 이뤄져 있는 경우, 테이블 중심 테스트로 수행하면 코드 중복을 피할 수 있어 로직을 변경하거나 새로운 케이스를 추가하기 쉽다는 장점이 있다. 작성한 테스트 코드에는 테스트 구조가 비슷하고, 라우팅 설정 등 공통된 부분이 많아서 테이블 중심 테스트를 선택하게 되었다.\nfunc setupRouter() *gin.Engine { r := gin.Default() r.Use(errorutils.ErrorMiddleware()) return r } func TestSuccessResponse(t *testing.T) { r := setupRouter() res := errorutils.NewSuccessBaseResponse(nil) // Set table tests := []struct { description string fn func(*gin.Context) expectedCode int path string }{ { // Ok Success description: \u0026#34;OKSuccess\u0026#34;, fn: func(c *gin.Context) { res.OKSuccess(c) }, expectedCode: 200, path: \u0026#34;/test/ok\u0026#34;, }, { // Created Success description: \u0026#34;CreatedSuccess\u0026#34;, fn: func(c *gin.Context) { res.CreatedSuccess(c) }, expectedCode: 201, path: \u0026#34;/test/created\u0026#34;, }, } for _, tc := range tests { t.Run(tc.description, func(t *testing.T) { w := httptest.NewRecorder() req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, tc.path, nil) // Specific handler function and serve r.GET(tc.path, tc.fn) r.ServeHTTP(w, req) if w.Code != tc.expectedCode { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, tc.expectedCode, w.Code) } }) } } 테스트 코드를 실행하면 아래와 같은 결과를 얻을 수 있다.\n마치며 # 하나의 간단한 CRUD가 있는 서비스 2개를 가지고 코드를 여러번 수정했다. 그 과정에서 다양한 오류를 만났고, 테스트 코드의 중요성도 확실히 알았다. 특히 이번에 테스트 코드를 작성하면서 오류를 많이 마주 했는데, 이를 재빠르게 수정하면서 테스트의 중요성을 느끼게 되었다.\nhttps://pjh3749.tistory.com/273\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://gin-gonic.com/docs/testing/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://bugoverdose.github.io/development/go-table-driven-tests/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"11 May 2024","externalUrl":null,"permalink":"/project/todopoint/gin-fix1-error/","section":"Projects","summary":"Go를 활용하여 직접 2개의 서비스를 만들고 나니, 구현할때 지나쳤던 에러들이 큰 눈덩이로 변해서 덮쳐왔다.","title":"Todopoint 서버코드 개선기 - 1. 공동 에러 처리하기","type":"project"},{"content":"","date":"8 May 2024","externalUrl":null,"permalink":"/tags/flutter/","section":"Tags","summary":"","title":"Flutter","type":"tags"},{"content":" MVVM 아키텍쳐 # Model, ViewModel, View의 줄임말 Model : 애플리케이션의 데이터 및 비즈니스 로직 View Model : View에 표시되는 데이터를 관리한다. 상태를 변경시키고 보여주는 로직이 포함되어 있다. View : 애플리케이션의 사용자 인터페이스 _ 출처 - : https://medium.com/flutterworld/flutter-mvvm-architecture-f8bed2521958 _\n상태 관리 도구 # 위에서 View Model에는 상태를 변경하고 표시해주는 로직이 필요하다고 있다. 이걸 쉽게 해주는 플러터 라이브러리가 있다. 대표적으로 GetX, Provider, Riverpod, bloc가 있다.\n기술적인 측면에서 본다면 Provider, bloc는 BuildContext를 통해 의존성을 주입한 반면 GetX는 그렇지 않는다. GetX가 생산성 측면에서는 더욱 효율적이나 BuildContext를 사용한 의존성 주입의 부재로 예기치 못한 문제가 발생할 수 있다. RiverPod과 Provider의 개발자는 동일하며, Provider의 단점을 보완하여 Riverpod를 만들었다고 한다. 그래서 전반적인 매커니즘은 비슷하다. 1\n최종적으로 Riverpod를 선택하게 되었다.\nBuildContext를 사용한 의존성 주입 # BuildContext는 Flutter가 최상위 위젯 노드부터 하위 노드에게 BuildContext를 전달하면서 그려나간다. 즉, BuildContext를 통해 최상위 부모 노드를 추적하면서 자신에 대한 여러 정보들을 찾을 수 있다는 것이다. 2\n_ 출처 - 라인 블로그, # Flutter 인기 아키텍처 라이브러리 3종 비교 분석 - GetX vs BLoC vs Provider\n프로젝트 구조 # 프로젝트 구조는 총 4개의 폴더로 이뤄져 있다.\nview : 사용자 인터페이스를 나타낸다. provider : 상태값을 관리한다. repository : 데이터를 접근하기 위해 사용된다. 서버에 대한 요청도 포함된다. model : 실제로 사용할 데이터를 정의한다. 예시 - TodoPoint Main View # Todopoint는 할일을 마무리하면 포인트를 얻는 앱이다. 그래서 TodoScreen에서 표시되어야 할 상태가 크게 두 가지이다.\n캘린더에 있는 포인트 할일 목록 사용자 인터페이스로 요청을 보내게 되면, provider를 지나 repository를 활용해 서버와 통신하여 원하는 정보를 얻는다. provider에 상태를 저장(캐싱)하여 다시 사용자에게 보여주도록 구현할 수 있다.\nReference # Flutter: MVVM Architecture MVVM Pattern in Flutter 1 -MVVM의 기본 구조 라인 블로그, Flutter 인기 아키텍처 라이브러리 3종 비교 분석 - GetX vs BLoC vs Provider https://engineering.linecorp.com/ko/blog/flutter-architecture-getx-bloc-provider\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://riverpod.dev/docs/from_provider/provider_vs_riverpod#reading-providers-buildcontext\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"8 May 2024","externalUrl":null,"permalink":"/project/todopoint/flutter-project-architecture/","section":"Projects","summary":"MVVM 아키텍쳐 # Model, ViewModel, View의 줄임말 Model : 애플리케이션의 데이터 및 비즈니스 로직 View Model : View에 표시되는 데이터를 관리한다.","title":"Flutter - Flutter 프로젝트 구조","type":"project"},{"content":"","date":"1 May 2024","externalUrl":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"AWS","type":"tags"},{"content":" EKS # Amazon Web Services(AWS)에 Kubernetes 컨트롤 플레인을 설치, 운영 및 유지 관리할 필요가 없는 관리형 서비스이다1.\nECS vs EKS # 둘 다 컨테이너 오케스트레이션이라는 점에서 공통점을 가짐 ECS는 AWS가 만든 자체적인 오케스트레이션 구조로 K8S 구조와 완전 다름 K8S는 오픈소스가 크게 활성화되어 있고, 다양한 플러그를 사용할 수 있음 ECS는 오픈소스가 크게 활성화되어 있지 않음. Auto-scaling 측면에서 EKS는 수동 및 자동 배포가 가능하지만 ECS는 수동으로만 가능하다. 오류 수정하는데 ECS는 전문가가 필요함 📌 자세한 사항은 물통꿀꿀이님의 블로그, [AWS] ECS vs Kubernetes를 참고하길 바람.\nEKS가 무조건 정답은 아니다. 프로젝트에 따라서는 ECS가 더 적합한 선택지일 수 있다.\nECS 적용 사례 - 밍글 왜 EKS 설치는 어려운가? # 우리가 알고 있는 쿠버네티스 구조와 달리 쿠버네티스는 일부 도구만 제공하고, 나머지는 별도의 설치가 필요하다. 이런 이유로 버전 관리가 어려워지기도 한다.\n쿠버네티스 제공 : kube-proxy, kubelet CNCF Graduated Project를 보면 etcd, coreDNS 등을 볼 수 있다. EKS 구조 # 앞서 말했듯이 직접 구축하게 되면, 관리해야 하는 요소들이 많다. 이러한 어려움을 덜어내고자 EKS를 사용할 수 있다. EKS는 관리형 \b서비스로서 Control Plane를 직접 구성하지 않고 K8S를 사용할 수 있다. 출처 - https://kubernetes.io/docs/concepts/architecture/\nEKS 특징 # EKS CNI를 활용하여 VPC 네트워크 상에서 파드간 통신 가능 IAM을 활용하여 권한 설정 가능 AWS가 가용 영역별 API Server ,etcd 배포하여 고가용성 보장 eksctl를 활용하여 워커노드를 custom할 수 있음. 📌 자세한 사항은 Jaden Park님의 블로그, Amazon EKS 란?를 참고하길 바란다.\nAWS Side Workflow # 출처- https://nearhome.tistory.com/128\n쿠버네티스의 api 서버를 각 가용영역에 배포 api 데이터, 쿠버네티스의 상태 데이터를 확인하기 위해 etcd를 같이 배포 쿠버네티스에서 오는 call 에 대한 IAM 구성 쿠버네티스 마스터 노드의 오토스케일링 설정 클러스터가 안정적으로 구현하도록 여기에 연결할 수 있는 로드밸런서를 구성 Reference # 초보자를 위한 EKS 맛 보기 ECS vs Kubernetes https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/what-is-eks.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 May 2024","externalUrl":null,"permalink":"/posts/what-is-eks/","section":"Posts","summary":"EKS # Amazon Web Services(AWS)에 Kubernetes 컨트롤 플레인을 설치, 운영 및 유지 관리할 필요가 없는 관리형 서비스이다1.","title":"AWS - EKS란 무엇인가","type":"posts"},{"content":"","date":"1 May 2024","externalUrl":null,"permalink":"/tags/eks/","section":"Tags","summary":"","title":"EKS","type":"tags"},{"content":"","date":"1 May 2024","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":" Introduction # Terraform 코드를 분석하고 있었다. 어디에서는 IAM을 쓰고, 어디에서는 Profile을 쓴다. 과연 그 둘의 차이점은 무엇일까? 알아보도록 하자!\nProfile # Amazon Ec2는 IAM role을 가진 profile을 사용하게 된다.\n질문 1. awscli를 통해 profile을 지정할 수 있는데, 이것도 Instance Profile인가? # If you use the AWS CLI, API, or an AWS SDK to create a role, you create the role and instance profile as separate actions, with potentially different names. If you then use the AWS CLI, API, or an AWS SDK to launch an instance with an IAM role or to attach an IAM role to an instance, specify the instance profile name. 출처 - 공식 문서\n질문이 잘못되었다. EC2는 해당 IAM Role을 가진 Profile을 사용한다. 그래서 awscli의 경우 \u0026ndash;profile을 통해 직접 profile 이름을 지정할 수 있다. 왜 필요할까? # aws cli를 사용할 때 profile 기능을 이용하면 여러개의 자격 증명을 등록하고 스위칭해서 효율적으로 사용할 수 있습니다.\n출처 - https://cloudest.oopy.io/posting/101\n질문 2. IAM Role과의 차이점은? # Profile이 필요한 이유는 여러개의 자격 증명을 등록하고 스위칭해서 효율적으로 사용하기 위함이라고 했다. 특징을 봤을때 IAM의 Role과 비슷해 보였다.\nRoles are designed to be “assumed” by other principals which do define “who am I?”, such as users, Amazon services, and EC2 instances An instance profile, on the other hand, defines “who am I?” Just like an IAM user represents a person, an instance profile represents EC2 instances. The only permissions an EC2 instance profile has is the power to assume a role.\n출처 - https://www.quora.com/In-AWS-what-is-the-difference-between-a-role-and-an-instance-profile\nIAM Role은 무엇을 할 수 있는지에 대한 행위를 정의하는 것이라면 Profile Instance는 \u0026ldquo;누가 만들었는지를 정의하기\u0026rdquo; 위함이라면 보면 된다.\nConclusion # 내가 이러한 궁금증을 가지게 된 것은 IAM을 한사람에게만 부여된다고 생각했기 때문이었다. 그런 맥락에서는 profile이 필요 없기 때문이다. Reference # https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html ","date":"16 April 2024","externalUrl":null,"permalink":"/posts/iam-and-profile/","section":"Posts","summary":"Introduction # Terraform 코드를 분석하고 있었다.","title":"AWS - IAM 그리고 Profile","type":"posts"},{"content":"이전에는 Gin이 어떻게 예외 처리를 하는지 언급했다. 이제부터 직접 구현하고자 한다.\nError Wrapping # 직접 제작한 에러 코드인 WebCode와 에러를 감싼 NetError를 만들었다.\ntype NetError struct { Code codes.WebCode Err error } 프로젝트 구현할때 주로 gin 혹은 ent 라이브러리를 쓴다. 별도의 Error 구조체(NetError)를 정의함으로써 Err에 gin 혹은 ent 에러를 담겠다는 의미인 것이다.\nGin에서의 예외 처리 # Gin Error() 함수에 의하면 Gin의 Context에 Error를 담은 후에 Middleware에서 처리하는 것을 권장하고 있다.\nError attaches an error to the current context. The error is pushed to a list of errors. It\u0026rsquo;s a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.\n라이브러리 코드를 보면 Errors 필드가 정의되어 있는데, errorMsg는 []*Error 에러 리스트로 타입을 가지고 있다. 위의 설명대로 error의 리스트가 Context 내부에 구현되어 있는 것이다.\n// gin/context.go type Context struct { // ... Errors errorMsgs // .. } // gin/errors.go type errorMsgs []*Error 즉, ctx.Error를 활용하여 입력받은 에러를 Gin의 에러로 감싼 후에 Context의 Errors 리스트에 넣게 된다.\n// gin/context.go // Error attaches an error to the current context. The error is pushed to a list of errors.// It\u0026#39;s a good idea to call Error for each error that occurred during the resolution of a request.// A middleware can be used to collect all the errors and push them to a database together, // print a log, or append it in the HTTP response. // Error will panic if err is nil. func (c *Context) Error(err error) *Error { if err == nil { panic(\u0026#34;err is nil\u0026#34;) } var parsedError *Error ok := errors.As(err, \u0026amp;parsedError) if !ok { parsedError = \u0026amp;Error{ Err: err, Type: ErrorTypePrivate, } } c.Errors = append(c.Errors, parsedError) return parsedError } Context 내부에 있는 Error 리스트는 Middleware에서 처리하게 된다.\nGin에서는 HandlerFunc를 slice로 구현된 HandlerChain이 있는데, 이는 Gin이 각가지의 Handler를 Chain내에 넣고 처리하는 것이다.\ntype HandlersChain []HandlerFunc 그럼 오류를 어떻게 발생시키면 될까? HandlerChain 내에 있는 대기 중인(Pending) Handler를 호출하지 않도록 하면된다. 즉, Context를 Abort하면 되는 것이다. 그 이후에 처리할 Handler가 없어지면서 종료가 된다.\nAbort prevents pending handlers from being called. Note that this will not stop the current handler. Let\u0026rsquo;s say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers for this request are not called.\n프로젝트에 적용하기 # 절차 # 위의 내용을 가지고 실제로 적용해보자. 프로젝트 구성은 3계층으로 커스텀 에러 감싸기는 서비스 로직에 수행하도록 했다.\nService 계층에 Error Wrapping을 한다. Controller에 context 내에 있는 에러 리스트에 예외를 넣는다. Middleware에 Error Wrapping한 것을 Unwrapping 하면서 예외 타입을 학인한다. 커스텀 에러라면 WebCode에 따른 응답값을 반환한다. 그림으로 표현하자면 아래와 같다. 코드 # 코드는 아래의 두 사이트를 참고했습니다.\nNaver D2, Golang, 그대들은 어떻게 할 것인가 - 3. error 래핑 Naver D2, Golang, 그대들은 어떻게 할 것인가 - 4. error 핸들링 Service Layer # Persistence Layer에서 얻은 에러 값을 직접 받은 후에 Service 계층에서 적절하게 NetError로 감싼다.\n// service func (s *MemberService) CreateMember(ctx *gin.Context, req data.RegisterReq) (*ent.Member, *errorutils.NetError) { // Check member Exist existedMem, err := s.Store.GetMemberByEmail(ctx, req.Email) if err != nil { return nil, \u0026amp;errorutils.NetError{Code: codes.MemberInternalServerError, Err: err} } if ent.IsNotFound(err) { mem, err2 := s.Store.Create(ctx, req) if err2 != nil { return nil, \u0026amp;errorutils.NetError{Code: codes.MemberCreationError, Err: err2} } return mem, nil } return existedMem, nil } Controller Layer # Controller는 Service 계층에서 감싼 커스텀 에러를 받은 후에 Context의 에러 리스트에 넣는다.\nfunc (controller *MemberController) RegisterMember(ctx *gin.Context) { req := data.RegisterReq{} err := ctx.ShouldBindJSON(\u0026amp;req) if err != nil { _ = ctx.Error(errorutils.NewNetError(codes.MemberInvalidJson, err)) return } // Create member mem, err2 := controller.service.CreateMember(ctx, req) if err2 != nil { // Service 계층에서 받은 에러를 Context 내 에러 리스트에 넣는다. _ = ctx.Error(err2) return } mid := data.MemberId{MemberId: mem.ID} response.SuccessWith(ctx, codes.MemberCreationSuccess, mid) } Middleware # 에러 응답값을 반환할 HandlerFunc를 구현한다.\nNext를 활용하여 대기 중인 핸들러를 실행시킨다. errors.As를 활용하여 Context 에러 리스트에 있는 에러가 커스텀 에러인지 확인한다. 정확히 말하자면 에러를 unwrapping하면서 커스텀 에러인지 확인한 후에 있다면 netError에 넣게 된다. WebCode를 활용하여 응답값을 얻은 후 AbortWithStatusJson 를 활용하여 Response json을 전송한다. func ErrorHandler() gin.HandlerFunc { return func(ctx *gin.Context) { // Pending 중인 핸들러 실행 ctx.Next() // JSON이 두번 쓰이는 것을 대비해서 Body 확인 isBodyWritten := ctx.Writer.Written() err := ctx.Errors.Last() if err != nil { // 커스텀 에러인지 확인 var netErr *errorutils.NetError if errors.As(err, \u0026amp;netErr) { code := netErr.GetCode() statusCode := codes.GetStatus(code) res := response.NewErrorResponse(code) if !isBodyWritten { ctx.AbortWithStatusJSON(int(statusCode), res) } } else { res := response.NewErrorResponse(codes.GlobalInternalServerError) if !isBodyWritten { ctx.AbortWithStatusJSON(http.StatusInternalServerError, res) } } } } } 마무리 # Go의 예외 매커니즘은 다른 언어와 달라서 틀을 잡는데 많은 시간을 사용했다. 공식 문서나 다른 사람들의 예제 코드를 분석하면서, Go 스러움이 무엇인지 자츰 배워간다는 느낌이다. 그러나 코드양이 많아지면서 오히려 코드가 복잡해지는 것 같기도 하다.\n","date":"10 April 2024","externalUrl":null,"permalink":"/posts/gin-error-handling2/","section":"Posts","summary":"이전에는 Gin이 어떻게 예외 처리를 하는지 언급했다.","title":"Gin 예외처리 - 2. 커스텀 예외처리","type":"posts"},{"content":" Go와 예외처리 # Go에서의 예외처리 # Go에서는 함수에서 반환된 에러 객체(error)로 처리한다. 다행히도 multi-return이 가능하기에 에러 반환을 더욱 수월하게 해줄 수 있다.\nf, err := Sqrt(-1) if err != nil { fmt.Println(err) } try ~ catch가 없는 이유 # 공식 문서에 의하면 try ~ catch는 난해한 코드를 생성하며, 개발자에게 너무많은 일반적인 예외를 처리하도록 장려한다고 한다.\nWe believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.\n다른 언어처럼 try ~ catch 를 어렴풋이 구현할 수 있다. 중간에 실행의 흐름을 끊는 panic 함수를 사용하는 것이다. 하지만 반대로 생각하자면 모든 에러들을 panic으로 처리해야 할까? Go에서는 그것이 아니라는 것이다. 이런 이유로 Go는 시의적절하기 예외처리할 수 있도록 error를 반환하는 방식으로 처리하게 된다.\nError - Wrapping # Go에서는 에러처리할 때 Error 객체를 넘겨준다고 한다. 물론 일반 에러 객체를 넘겨줄 수 있지만 개발자가 직접 만든 에러를 만들어서 넘겨줄 수 있다. Error Wrapping이란 쉽게 말하자면 error 객체를 감싸는 또다른 구조체를 만드는 것이라고 보면 된다.\ngin에서의 Error를 봐보자. gin의 Error 내에 필드로 error가 존재한다. 이러한 과정을 Error Wrapping이라고 보면 된다.\n// Error represents a error\u0026#39;s specification. type Error struct { Err error Type ErrorType Meta any } 그럼 예를 들어보자. ctx.Error를 실행했는데 의도치 않게 errors.As가 적절하게 실행되지 않는다고 가정해보자. error.As는 Error Type을 확인하는 함수인데, 만약에 타입이 적절하지 않는다면, 입력한 error을 감싼 Error를 반환하게 된다.\nfunc (c *Context) Error(err error) *Error { if err == nil { panic(\u0026#34;err is nil\u0026#34;) } var parsedError *Error ok := errors.As(err, \u0026amp;parsedError) if !ok { parsedError = \u0026amp;Error{ Err: err, Type: ErrorTypePrivate, } } c.Errors = append(c.Errors, parsedError) return parsedError } 그럼 원본 에러(error)에 접근할 수 있을까? 바로 Unwrap를 통해 얻을 수 있은 것이다.\n// Unwrap returns the wrapped error, to allow interoperability with errors.Is(), errors.As() and errors.Unwrap() func (msg *Error) Unwrap() error { return msg.Err } 그림으로 표현하면 아래와 같다.\n기존의 문제점 # Gin Context의 잘못된 활용법 # 공식 문서에서 말하는 Context는 데드라인, 취소 시그널, API에 대한 경계값을 가지는 값으로 정의된다. 그래서 조건에 따라 실행이 중단될 수 있다는 것으로 이해했다. gin은 자체적인 Context를 가지고 있으며, context를 중단시킬 수 있는 여러 함수들이 존재한다.\nService Layer에서 커스텀 에러 타입으로 반환하도록 구현했다.\nfunc (controller *MemberController) RegisterMember(ctx *gin.Context, req request.RegisterReq) { req = request.RegisterReq{} err := ctx.ShouldBindJSON(req) // ... // Create member err2 := controller.service.CreateMember(ctx, req) if err2 != nil { errorutils.ErrorFunc(ctx, err2) return } webutils.Success(ctx) } 커스텀 에러 타입을 자세히 보면, 자체적으로 제작한 에러 코드와 error을 담을 Err 필드가 존재한다.\ntype Error struct { // Code is a custom error codes ErrorType ErrorType // Err is a error string Err error // Description is a human-friendly message. Description string } 애플리케이션에 오류 발생시 현재 실행을 멈추고, 응답값을 보내는 ErrorFunc도 만들었다.\nfunc ErrorFunc(ctx *gin.Context, err *Error) { res := getCode(err.ErrorType) ctx.AbortWithStatusJSON(res.Code, res) return } 공식 문서 에 의하면AbortWithStatusJSON에는 내부적으로 Context를 중단시킬 수 있는Abort 함수를 사용한다. 구체적으로 Abort 함수는 현재의 handler는 그대로 남지만, 그 이후의 handler를 처리하지 않겠다는 것이다.\nAbort prevents pending handlers from being called. Note that this will not stop the current handler. Let\u0026rsquo;s say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers for this request are not called.\n문장을 보면서 내가 Gin 프레임워크의 에러처리를 완전히 잘못했음을 깨닫게 되었다.\nGin Error 미사용 # 공식 문서에 의하면 Gin은 자신들의 Error를 사용하는 것을 권장하며, middleware가 이를 처리하여 오류 response를 처리하라고 명시되어 있다.\nError attaches an error to the current context. The error is pushed to a list of errors. It\u0026rsquo;s a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.\n즉, 오류가 발생할때마다 gin의 Context에서 제공해주는 Error로 감싸며, Middleware에 있는 Handler가 이를 순차적으로 처리해야 한다는 것이다.\n2부에서는 # 지금까지는 내가 만들었던 예외처리에는 어떠한 문제점이 있는지 확인해봤다. 2부에서는 위에서 설명한 잘못된 에러처리를 공식문서에서 제시한 올바른 에러처리를 구현하고자 한다.\nMiddleware에 Handler 구현 gin.Error를 활용하여 Error를 wrapping하고, Middleware에서 처리하기 ","date":"3 April 2024","externalUrl":null,"permalink":"/posts/gin-error-handling1/","section":"Posts","summary":"Go와 예외처리 # Go에서의 예외처리 # Go에서는 함수에서 반환된 에러 객체(error)로 처리한다.","title":"Gin 예외처리 - 1. Go Error","type":"posts"},{"content":"","date":"25 January 2024","externalUrl":null,"permalink":"/tags/terraform/","section":"Tags","summary":"","title":"Terraform","type":"tags"},{"content":" Terraform 이란 # HashiCorp에서 오픈소스로 개발중인, 클라우드 및 온프로미스 인프라를 코드로 관리할 수 있는 코드이다. 인프라 환경 구성 시 선언적 코드형식을 사용하여 리소스를 생성, 수정, 삭제하여 관리가 가능한 laC(Infrastructure as Code) 프로비저닝 도구이다.\nTerraform 작동 방식 # 주로 Write, Plan, Apply 절차로 이뤄진다.\nWrite : Hashicorp에서 자체 개발한 HCL 언어로 스크립트 작성 Plan : 상태를 비교하며 변경점을 사용자에게 보여줌 Apply : 실행하는 단계, 순차적으로 실행 의존 관계에 따라 순서를 명시할 수 있다. 출처 - Terraform 공식 홈페이지\n상태 비교를 통해 휴먼 에러를 줄일 수 있다. 그러나 코드의 무게가 무거워지면, 실행하는데 오래걸리는 원인이 될 수 있다. 그 외에도 다양한 단점이 존재할 것이다. 그럼에도 불구하고 생산성 측면, 종속성 그래프 등 장점들이 더 크기 때문에 사용하는 것이다.\n클라우드 컴퓨팅 환경은 참조된 리소스가 처음의 리소스를 참조하는 순환루프 문제를 지니고 있다. 무한한 반복으로 인해 시스템이 빠르게 고갈되고, 성능이 저하된다. Terraform에서는 리소스의 참조 내용을 그래프로 보여주는 Resource Graph를 제공해주는데, 이를 활용해 순환루프 문제를 예방할 수 있다.\n연습 # 자세한 문법은 Terraform Language Documentation을 참고하길 바란다.\n시나리오 # AWS를 활용한다. 개발, 운영 VPC를 구축한다. 각 VPC에서 private, public subnet이 존재한다. 외부와 통신을 위해 internet gateway와 내부 리소스끼리만 통신할 수 있는 NAT gateway를 설치한다. 출처 - 저자\n구현 # AWS를 활용한다. Terraform AWS Registry에서 제공해주는 코드를 그대로 사용한다. 나의 경우 region을 ap-northeast-2 로 설정했다.\n// ./main.tf terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 5.0\u0026#34; } } } # Configure the AWS Provider provider \u0026#34;aws\u0026#34; { region = \u0026#34;ap-northeast-2\u0026#34; } 개발 운영 vpc를 구축한다. vpc 모듈을 별도로 만들어 코드를 재사용했고, env를 변수로 삼아 리소스의 이름에 개발 환경을 명시하도록 했다.\n// ./main.tf // For Dev module \u0026#34;dev_vpc\u0026#34; { source = \u0026#34;./vpc.d\u0026#34; env = \u0026#34;dev\u0026#34; } // For Production module \u0026#34;prd_vpc\u0026#34; { source = \u0026#34;./vpc.d\u0026#34; env = \u0026#34;prd\u0026#34; } 모듈의 main.tf에는 public, private Subnet 그리고 NAT gateway, Internet gateway를 생성하는 코드를 작성했다.\nPrivate Subnet을 구성하기 위해서는 라우팅 테이블이 필요하지만, 임시이므로 Private NAT Gateway만 작성했다. 여기서 주목해야 할 점은 NAT, Internet Gateway의 경우 Subnet이 우선적으로 만들어져야 실행된다.(만약에 그러지 않는다면 오류가 뜬다.) 그러므로 코드를 작성할때 각 리소스의 의존성을 고려해서 작성해야 한다.\n// ./vpc.d/main.tf terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 5.0\u0026#34; } } } // Configure the AWS Provider provider \u0026#34;aws\u0026#34; { region = \u0026#34;ap-northeast-2\u0026#34; } // Create a VPC resource \u0026#34;aws_vpc\u0026#34; \u0026#34;default\u0026#34; { cidr_block = \u0026#34;10.0.0.0/16\u0026#34; tags = { Name = \u0026#34;terraform_default_vpc_${var.env}\u0026#34; } } // public subnet resource \u0026#34;aws_subnet\u0026#34; \u0026#34;public_subnet_1\u0026#34; { vpc_id = aws_vpc.default.id cidr_block = \u0026#34;10.0.0.0/24\u0026#34; tags = { Name = \u0026#34;terraform_public_subnet_1_${var.env}\u0026#34; } } // private subnet resource \u0026#34;aws_subnet\u0026#34; \u0026#34;private_subnet_1\u0026#34; { vpc_id = aws_vpc.default.id cidr_block = \u0026#34;10.0.10.0/24\u0026#34; tags = { Name = \u0026#34;terraform_private_subnet_1_${var.env}\u0026#34; } } // private NAT resource \u0026#34;aws_nat_gateway\u0026#34; \u0026#34;private_nat\u0026#34; { connectivity_type = \u0026#34;private\u0026#34; subnet_id = aws_subnet.private_subnet_1.id tags = { Name = \u0026#34;terraform_nat_${var.env}\u0026#34; } } // Internet gateway resource \u0026#34;aws_internet_gateway\u0026#34; \u0026#34;igw\u0026#34; { vpc_id = aws_vpc.default.id tags = { Name = \u0026#34;terraform_igw_${var.env}\u0026#34; } } Terraform 도입과 관련된 기술 블로그 # 좌충우돌 Terraform 입문기, 우아한형제들 기술블로그 DevOps팀의 Terraform 모험 Terraform IaC 도구를 활용한 AWS 웹콘솔 클릭 노가다 해방기 → 다들 웹콘솔에서의 해방을 외치고 있었다..\n","date":"25 January 2024","externalUrl":null,"permalink":"/posts/basic-terraform1/","section":"Posts","summary":"Terraform 이란 # HashiCorp에서 오픈소스로 개발중인, 클라우드 및 온프로미스 인프라를 코드로 관리할 수 있는 코드이다.","title":"Terraform 기초 맛보기 - 1. 기본 문법 익히기","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/newsletter/","section":"Newsletter","summary":"","title":"Newsletter","type":"newsletter"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]